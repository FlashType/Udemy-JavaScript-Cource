"use strict";
//[1]
let x = 5;
alert(x++); //*ответ 5, т.к. это постфиксный инкремент
//[2]
console.log(typeof ([] + false - null + true)); //*type :string //NaN т.к. пустой массив всё переводит в строчный тип данных
//*а "false" - null не имеет смысла, поэтмоу ответ NaN
//[3]
let y = 1;
let z = y = 2;
alert(y);//*2
///////////////
//[4]//!NuN
console.log([] + 1 + 2);//*"12"
///////////////
//[5]//!"10"
alert("1"[0]);//*1 т.к это обычное обращение к первому на странице элементу
///////////////
//[6]
//Чему равно 2 && 1 && null && 0 && undefined?
console.log(2 && 1 && null && 0 && undefined);//* null, т.к оператор && идёт слева на право и останавливается на первом
//* ложном булиновом значении. null, 0, undefined,
//[7]
//Есть ли разница между выражениями? !!(a & b) и (a & b)?

console.log(!!(1 & 2) == (1 & 2));//true
console.log(!!(1 & 2) === (1 & 2));//false

//* нет,т.к. первое выражение превращено в булиново значение при помощи [!!]

//[8]
//Что выведет код: alert(null || 2&&3 || 4);
console.log(null || 2 && 3 || 4);


/*Оператор && приоритетней оператора || , поэтому порядок выполнения JavaScript'ом данного выражения будет следующим:*/
//! && заинается на ЛЖИ, а || на ПРАВДЕ

//* [1] (2 && 3); 
console.log(2 && 3);//*3
//*[2] null || 3
console.log(null || 3);//*3, т.к. null всегда false
//*[3] 
console.log(3 || 4);//*3, т.к. 3 - true
//* Ответ: 3;

//[9]
let a = [1, 2, 3],
	b = [1, 2, 3];
	// Правда ли,что а == b?
	console.log(a == b);//*false, т.к. это 2 разных массива,пусть и с одиноковыми данными
	
	//[10]
	//Что выведет код alert(+'Infinity');
	console.log(+"Infinity");// Infinity в числовом типе данных

	//[11]
	//Верно ли сравнение? "Ёжик">"Яблоко"?
	console.log("Ёжик">"Яблоко");//false, т.к. индексация букв устроена так,что "a<б<в<г<д<е..."
	
	//[12]
	//Чему равно 0 || " " || 2 || undefined || true || false?
	//       false||false||true||false     || true || false
	console.log(0 || " " || 2 || undefined || true || false);//*ответ 2, т.к 2 = true.

	
	